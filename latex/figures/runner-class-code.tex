\begin{listing}
\begin{minted}{cpp}
/* ... */
template <IsQueueWith<u64> Q, IsMeasurerPair M,
    IsWaiterPair W, bool MEASURE_FAILED = false>
class Runner {
  public:
    template <typename P>
    explicit Runner(Q* queue, const P& params)
        : _queue(queue), _measurer(M(params.msg_count)),
          _waiter(W(params)), _msg_count(params.msg_count) {}

    void run() { /* ... */ }

    void write_results(std::ostream* out) { /* ... */ }

  private:
    Q* _queue;
    M _measurer;
    W _waiter;
    usize _msg_count;
    volatile bool _start = false;
    CACHE_ALIGNED u64 _data_sink;

    void producer() {
        // wait for start
        while (!_start) { }
        // do test
        _waiter.tx.start();
        for (usize i = 0; i < _msg_count; i++) {
            _measurer.tx.pre();
            auto data = get_timestamp();
            while (!_queue->enqueue(data)) {
                if constexpr (!MEASURE_FAILED) _measurer.tx.pre();
            }
            _measurer.tx.post();
            _waiter.tx.wait();
        }
    }

    void consumer() {
        // wait for start
        while (!_start) { }
        // do test
        _waiter.rx.start();
        for (usize i = 0; i < _msg_count; i++) {
            _measurer.rx.pre();
            std::optional<u64> data = std::nullopt;
            while (!((data = _queue->dequeue()))) {
                if constexpr (!MEASURE_FAILED) _measurer.rx.pre();
            }
            _data_sink += *data;
            _measurer.rx.post();
            _waiter.rx.wait();
        }
    }
};
\end{minted}
\caption{The implementation of the runner class in C++, with some parts ommited.}
\label{fig:runner-class-code}
\end{listing}
